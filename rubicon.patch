? builtin/TestPack.rb
Index: builtin/ArrayBase.rb
===================================================================
RCS file: /var/cvs/rubytests/rubicon/builtin/ArrayBase.rb,v
retrieving revision 1.21
diff -u -d -u -r1.21 ArrayBase.rb
--- builtin/ArrayBase.rb	11 Nov 2004 22:15:12 -0000	1.21
+++ builtin/ArrayBase.rb	24 Apr 2005 20:15:40 -0000
@@ -893,90 +893,6 @@
     assert_equal(3, @cls[1, nil, nil, 2, nil, 3, nil].nitems)
   end
 
-  def test_pack
-    a = @cls[*%w( cat wombat x yy)]
-    assert_equal("catwomx  yy ", a.pack("A3A3A3A3"))
-    assert_equal("cat", a.pack("A*"))
-    assert_equal("cwx  yy ", a.pack("A3@1A3@2A3A3"))
-    assert_equal("catwomx\000\000yy\000", a.pack("a3a3a3a3"))
-    assert_equal("cat", a.pack("a*"))
-    assert_equal("ca", a.pack("a2"))
-    assert_equal("cat\000\000", a.pack("a5"))
-
-    assert_equal("\x61",     @cls["01100001"].pack("B8"))
-    assert_equal("\x61",     @cls["01100001"].pack("B*"))
-    assert_equal("\x61",     @cls["0110000100110111"].pack("B8"))
-    assert_equal("\x61\x37", @cls["0110000100110111"].pack("B16"))
-    assert_equal("\x61\x37", @cls["01100001", "00110111"].pack("B8B8"))
-    assert_equal("\x60",     @cls["01100001"].pack("B4"))
-    assert_equal("\x40",     @cls["01100001"].pack("B2"))
-
-    assert_equal("\x86",     @cls["01100001"].pack("b8"))
-    assert_equal("\x86",     @cls["01100001"].pack("b*"))
-    assert_equal("\x86",     @cls["0110000100110111"].pack("b8"))
-    assert_equal("\x86\xec", @cls["0110000100110111"].pack("b16"))
-    assert_equal("\x86\xec", @cls["01100001", "00110111"].pack("b8b8"))
-    assert_equal("\x06",     @cls["01100001"].pack("b4"))
-    assert_equal("\x02",     @cls["01100001"].pack("b2"))
-
-    assert_equal("ABC",      @cls[ 65, 66, 67 ].pack("C3"))
-    assert_equal("\377BC",   @cls[ -1, 66, 67 ].pack("C*"))
-    assert_equal("ABC",      @cls[ 65, 66, 67 ].pack("c3"))
-    assert_equal("\377BC",   @cls[ -1, 66, 67 ].pack("c*"))
-
-    
-    assert_equal("AB\n\x10",  @cls["4142", "0a", "12"].pack("H4H2H1"))
-    assert_equal("AB\n\x02",  @cls["1424", "a0", "21"].pack("h4h2h1"))
-
-    assert_equal("abc=02def=\ncat=\n=01=\n", 
-                 @cls["abc\002def", "cat", "\001"].pack("M9M3M4"))
-
-    assert_equal("aGVsbG8K\n",  @cls["hello\n"].pack("m"))
-    assert_equal(",:&5L;&\\*:&5L;&\\*\n",  @cls["hello\nhello\n"].pack("u"))
-
-    assert_equal("\xc2\xa9B\xe2\x89\xa0", @cls[0xa9, 0x42, 0x2260].pack("U*"))
-
-
-    format = "c2x5CCxsdils_l_a6";
-    # Need the expression in here to force ary[5] to be numeric.  This avoids
-    # test2 failing because ary2 goes str->numeric->str and ary does not.
-    ary = [1, -100, 127, 128, 32767, 987.654321098/100.0,
-      12345, 123456, -32767, -123456, "abcdef"]
-    x    = ary.pack(format)
-    ary2 = x.unpack(format)
-
-    assert_equal(ary.length, ary2.length)
-    assert_equal(ary.join(':'), ary2.join(':'))
-    assert_not_nil(x =~ /def/)
-
-
-
-    skipping "Not tested:
-        D,d & double-precision float, native format\\
-        E & double-precision float, little-endian byte order\\
-        e & single-precision float, little-endian byte order\\
-        F,f & single-precision float, native format\\
-        G & double-precision float, network (big-endian) byte order\\
-        g & single-precision float, network (big-endian) byte order\\
-        I & unsigned integer\\
-        i & integer\\
-        L & unsigned long\\
-        l & long\\
-
-        N & long, network (big-endian) byte order\\
-        n & short, network (big-endian) byte-order\\
-        P & pointer to a structure (fixed-length string)\\
-        p & pointer to a null-terminated string\\
-        S & unsigned short\\
-        s & short\\
-        V & long, little-endian byte order\\
-        v & short, little-endian byte order\\
-        X & back up a byte\\
-        x & null byte\\
-        Z & ASCII string (null padded, count is width)\\
-"
-  end
-
   def test_pop
     a = @cls[ 'cat', 'dog' ]
     assert_equal('dog', a.pop)
@@ -1276,6 +1192,7 @@
       assert_equal([nil, nil], %w(a b c d e).values_at(-6, -500))
       assert_equal(%w(a c e),  %w(a b c d e).values_at(0.0, 2.0, 4.0)) # float as index
       assert_equal(%w(b),      %w(a b c d e).values_at(1.8)) # float as index
+      assert_equal(%w(b c d),  %w(a b c d e).values_at(1..3))
       assert_raises(TypeError) { %w(a b c).values_at(nil) }
       assert_raises(TypeError) { %w(a b c).values_at("x") }
       assert_raises(TypeError) { %w(a b c).values_at([]) }
@@ -1294,4 +1211,14 @@
     assert_equal(@cls[1,2], @cls[1, 2] | @cls[1, 2])
   end
 
+  def test_zip
+    a = @cls[4, 5, 6]
+    b = @cls[7, 8, 9]
+
+    assert_equal([[1, 4, 7], [2, 5, 8], [3, 6, 9]], @cls[1, 2, 3].zip(a, b))
+    assert_equal([[1, 4, 7], [2, 5, 8]], @cls[1, 2].zip(a, b))
+    assert_equal([[4, 1, 8], [5, 2, nil], [6, nil, nil]], a.zip([1, 2], [8]))
+  end
+
 end
+
Index: builtin/StringBase.rb
===================================================================
RCS file: /var/cvs/rubytests/rubicon/builtin/StringBase.rb,v
retrieving revision 1.16
diff -u -d -u -r1.16 StringBase.rb
--- builtin/StringBase.rb	9 Apr 2005 22:01:49 -0000	1.16
+++ builtin/StringBase.rb	24 Apr 2005 20:15:40 -0000
@@ -1325,83 +1325,6 @@
     assert_equal(S("h*o"), a)
   end
 
-  def test_unpack
-    a = [S("cat"),  S("wom"), S("x"), S("yy")]
-    assert_equal(a, S("catwomx  yy ").unpack(S("A3A3A3A3")))
-
-    assert_equal([S("cat")], S("cat  \000\000").unpack(S("A*")))
-    assert_equal([S("cwx"), S("wx"), S("x"), S("yy")],
-                   S("cwx  yy ").unpack(S("A3@1A3@2A3A3")))
-    assert_equal([S("cat"), S("wom"), S("x\000\000"), S("yy\000")],
-                  S("catwomx\000\000yy\000").unpack(S("a3a3a3a3")))
-    assert_equal([S("cat \000\000")], S("cat \000\000").unpack(S("a*")))
-    assert_equal([S("ca")], S("catdog").unpack(S("a2")))
-
-    assert_equal([S("cat\000\000")],
-                  S("cat\000\000\000\000\000dog").unpack(S("a5")))
-
-    assert_equal([S("01100001")], S("\x61").unpack(S("B8")))
-    assert_equal([S("01100001")], S("\x61").unpack(S("B*")))
-    assert_equal([S("0110000100110111")], S("\x61\x37").unpack(S("B16")))
-    assert_equal([S("01100001"), S("00110111")], S("\x61\x37").unpack(S("B8B8")))
-    assert_equal([S("0110")], S("\x60").unpack(S("B4")))
-
-    assert_equal([S("01")], S("\x40").unpack(S("B2")))
-
-    assert_equal([S("01100001")], S("\x86").unpack(S("b8")))
-    assert_equal([S("01100001")], S("\x86").unpack(S("b*")))
-
-    assert_equal([S("0110000100110111")], S("\x86\xec").unpack(S("b16")))
-    assert_equal([S("01100001"), S("00110111")], S("\x86\xec").unpack(S("b8b8")))
-
-    assert_equal([S("0110")], S("\x06").unpack(S("b4")))
-    assert_equal([S("01")], S("\x02").unpack(S("b2")))
-
-    assert_equal([ 65, 66, 67 ],  S("ABC").unpack(S("C3")))
-    assert_equal([ 255, 66, 67 ], S("\377BC").unpack("C*"))
-    assert_equal([ 65, 66, 67 ],  S("ABC").unpack("c3"))
-    assert_equal([ -1, 66, 67 ],  S("\377BC").unpack("c*"))
-
-    
-    assert_equal([S("4142"), S("0a"), S("1")], S("AB\n\x10").unpack(S("H4H2H1")))
-    assert_equal([S("1424"), S("a0"), S("2")], S("AB\n\x02").unpack(S("h4h2h1")))
-
-    assert_equal([S("abc\002defcat\001"), S(""), S("")],
-                 S("abc=02def=\ncat=\n=01=\n").unpack(S("M9M3M4")))
-
-    assert_equal([S("hello\n")], S("aGVsbG8K\n").unpack(S("m")))
-
-    assert_equal([S("hello\nhello\n")], S(",:&5L;&\\*:&5L;&\\*\n").unpack(S("u")))
-
-    assert_equal([0xa9, 0x42, 0x2260], S("\xc2\xa9B\xe2\x89\xa0").unpack(S("U*")))
-
-    skipping "Not tested:
-        D,d & double-precision float, native format\\
-        E & double-precision float, little-endian byte order\\
-        e & single-precision float, little-endian byte order\\
-        F,f & single-precision float, native format\\
-        G & double-precision float, network (big-endian) byte order\\
-        g & single-precision float, network (big-endian) byte order\\
-        I & unsigned integer\\
-        i & integer\\
-        L & unsigned long\\
-        l & long\\
-
-        m & string encoded in base64 (uuencoded)\\
-        N & long, network (big-endian) byte order\\
-        n & short, network (big-endian) byte-order\\
-        P & pointer to a structure (fixed-length string)\\
-        p & pointer to a null-terminated string\\
-        S & unsigned short\\
-        s & short\\
-        V & long, little-endian byte order\\
-        v & short, little-endian byte order\\
-        X & back up a byte\\
-        x & null byte\\
-        Z & ASCII string (null padded, count is width)\\
-"
-  end
-
   def test_upcase
     assert_equal(S("HELLO"), S("hello").upcase)
     assert_equal(S("HELLO"), S("hello").upcase)
Index: builtin/TestTime.rb
===================================================================
RCS file: /var/cvs/rubytests/rubicon/builtin/TestTime.rb,v
retrieving revision 1.7
diff -u -d -u -r1.7 TestTime.rb
--- builtin/TestTime.rb	24 Mar 2005 01:00:03 -0000	1.7
+++ builtin/TestTime.rb	24 Apr 2005 20:15:40 -0000
@@ -104,9 +104,16 @@
     end
   end
 
+  def setup
+    @utc = Time.utc(2001, 2, 3, 4, 5, 6)
+    @loc = Time.local(2001, 2, 3, 4, 5, 6)
+    @zone = Time.now.zone
+  end
+
   #
   # Ensure against time travel
   #
+
   def test_00sanity # ZenTest SKIP
     assert_operator Time.now.to_i, :>, 960312287 # Tue Jun  6 13:25:06 EDT 2000
   end
@@ -118,16 +125,24 @@
   end
 
   def test_class_at
-    t = Time.now
-    sec = t.to_i
+    loc = Time.now
+    sec = loc.to_i
     assert_equal(0, Time.at(0).to_i)
-    assert_equal(t, Time.at(t))
-    assert((Time.at(sec,1000000).to_f - Time.at(sec).to_f) == 1.0)
+    assert_equal(loc, Time.at(loc))
+    assert((Time.at(sec,1000000).to_f - Time.at(sec).to_f) == 1.0) # FIX
+  end
+
+  def test_class_at_utc
+    utc1 = Time.now.utc
+    utc2 = Time.at(utc1)
+    assert(utc1.utc?)
+    assert(utc2.utc?)
+    assert_equal(utc1.to_i, utc2.to_i)
   end
 
   def test_class_gm
     assert_raises(ArgumentError) { Time.gm }
-    assert(Time.gm(2000) != Time.local(2000))
+    assert_not_equal(Time.gm(2000), Time.local(2000))
     assert_equal(Time.gm(2000), Time.gm(2000,1,1,0,0,0))
     assert_equal(Time.gm(2000,nil,nil,nil,nil,nil), Time.gm(2000,1,1,0,0,0))
     assert_raises(ArgumentError) { Time.gm(2000,0) }
@@ -144,17 +159,9 @@
     assert_equal(Time.gm(*a),t)
   end
 
-  def test_class_httpdate
-    raise NotImplementedError, 'Need to write test_class_httpdate'
-  end
-
-  def test_class_iso8601
-    raise NotImplementedError, 'Need to write test_class_iso8601'
-  end
-
   def test_class_local
     assert_raises(ArgumentError) { Time.local }
-    assert(Time.gm(2000) != Time.local(2000))
+    assert_not_equal(Time.gm(2000), Time.local(2000))
     assert_equal(Time.local(2000), Time.local(2000,1,1,0,0,0))
     assert_equal(Time.local(2000,nil,nil,nil,nil,nil), Time.local(2000,1,1,0,0,0))
     assert_raises(ArgumentError) { Time.local(2000,0) }
@@ -176,7 +183,7 @@
     # Test insufficient arguments
     #
     assert_raises(ArgumentError) { Time.mktime }
-    assert(Time.gm(2000) != Time.mktime(2000))
+    assert_not_equal(Time.gm(2000), Time.mktime(2000))
     assert_equal(Time.mktime(2000), Time.mktime(2000,1,1,0,0,0))
     assert_equal(Time.mktime(2000,nil,nil,nil,nil,nil), Time.mktime(2000,1,1,0,0,0))
     assert_raises(ArgumentError) { Time.mktime(2000,0) }
@@ -197,24 +204,16 @@
     assert_equal(Time.mktime(*a),t)
   end
 
-  def test_class_now
-    t1 = Time.now
-    sleep 1
-    t2 = Time.now
+  def util_class_now(method)
+    t1 = Time.send(method)
+    sleep 0.1
+    t2 = Time.send(method)
     d = t2.to_f - t1.to_f
-    assert(d > 0.9 && d < 1.1)
-  end
-
-  def test_class_parse
-    raise NotImplementedError, 'Need to write test_class_parse'
-  end
-
-  def test_class_rfc2822
-    raise NotImplementedError, 'Need to write test_class_rfc2822'
+    assert_in_delta(0.1, d, 0.01)
   end
 
-  def test_class_rfc822
-    raise NotImplementedError, 'Need to write test_class_rfc822'
+  def test_class_now
+    util_class_now(:now)
   end
 
   def test_class_times
@@ -227,15 +226,7 @@
   end
 
   def test_class_utc
-    raise NotImplementedError, 'Need to write test_class_utc'
-  end
-
-  def test_class_xmlschema
-    raise NotImplementedError, 'Need to write test_class_xmlschema'
-  end
-
-  def test_class_zone_offset
-    raise NotImplementedError, 'Need to write test_class_zone_offset'
+    test_class_gm # TODO: refactor to ensure they really are synonyms
   end
 
   # Instance Methods:
@@ -258,7 +249,7 @@
         b = a.clone
 
         assert_equal(a, b)
-        assert(a.__id__ != b.__id__)
+        assert_not_equal(a.__id__, b.__id__)
         assert_equal(a.frozen?, b.frozen?)
         assert_equal(a.tainted?, b.tainted?)
       end
@@ -275,28 +266,49 @@
   end
 
   def test_dst_eh
-    raise NotImplementedError, 'Need to write test_dst_eh'
+    test_isdst # TODO: refactor to test that they really are the same
   end
 
   def test_eql_eh
-    t1=Time.now
-    t2=t1 
-    t2+= 2e-6
-    sleep(0.1)
-    assert(!t1.eql?(Time.now))
-    assert(!t1.eql?(t2))
+    t1 = Time.now
+    t2 = Time.at(t1)
+    t3 = t1 + 2e-6
+    t4 = t1 + 1
+    assert(t1.eql?(t1))
+    assert(t1.eql?(t2))
+    assert(!t1.eql?(t3))
+    assert(!t1.eql?(t4))
+    assert(!t1.eql?(t1.getutc))
   end
 
   def test_getgm
-    raise NotImplementedError, 'Need to write test_getgm'
+    # TODO: this only tests local -> gm
+    t1 = Time.now
+    loc = Time.at(t1)
+    assert(!t1.gmt?)
+    t2 = t1.getgm
+    assert(!t1.gmt?)
+    assert(t2.gmt?)
+    assert_equal(t1.asctime, loc.asctime)
+    assert_not_equal(t2.asctime, loc.asctime)
+    assert_not_equal(t1.asctime, t2.asctime)
   end
 
   def test_getlocal
-    raise NotImplementedError, 'Need to write test_getlocal'
+    # TODO: this only tests gm -> local
+    t1 = Time.now.gmtime
+    utc = Time.at(t1)
+    assert(t1.gmt?)
+    t2 = t1.getlocal
+    assert(t1.gmt?)
+    assert(!t2.gmt?)
+    assert_equal(t1, utc)
+    assert_not_equal(t2.asctime, utc.asctime)
+    assert_not_equal(t1, t2)
   end
 
   def test_getutc
-    raise NotImplementedError, 'Need to write test_getutc'
+    test_getgm # REFACTOR to test both calls
   end
 
   def test_gmt_eh
@@ -307,49 +319,42 @@
   end
 
   def test_gmt_offset
-    raise NotImplementedError, 'Need to write test_gmt_offset'
+    test_utc_offset # REFACTOR to test both methods
   end
 
   def test_gmtime
+    # TODO: this only tests local -> gm
     t = Time.now
     loc = Time.at(t)
     assert(!t.gmt?)
     t.gmtime
     assert(t.gmt?)
-    assert(t.asctime != loc.asctime)
+    assert_not_equal(t.asctime, loc.asctime)
   end
 
   def test_gmtoff
-    raise NotImplementedError, 'Need to write test_gmtoff'
+    test_utc_offset # REFACTOR to test both methods
   end
 
   def test_hash
-    t = Time.now
-    t2 = Time.at(t)
-    sleep(0.1)
-    t3 = Time.now
-    assert_equal(t.hash, t2.hash)
-    assert_not_equal(t.hash, t3.hash)
+    t1 = @utc
+    t2 = Time.at(t1)
+    t3 = @utc + 1
+    assert_equal(t1.hash, t2.hash)
+    assert_not_equal(t1.hash, t3.hash)
   end
 
   def test_hour
     checkComponent(:hour, 3)
   end
 
-  def test_httpdate
-    raise NotImplementedError, 'Need to write test_httpdate'
-  end
-
   def test_initialize
-    t1 = Time.new
-    sleep 1
-    t2 = Time.new
-    d = t2.to_f - t1.to_f
-    assert(d > 0.9 && d < 1.1)
+    util_class_now(:new)
   end
 
   def test_inspect
-    raise NotImplementedError, 'Need to write test_inspect'
+    assert_equal("Sat Feb 03 04:05:06 UTC 2001", @utc.inspect)
+    assert_equal("Sat Feb 03 04:05:06 #{@zone} 2001", @loc.inspect)
   end
 
   def test_isdst
@@ -360,50 +365,41 @@
     # work in some parts of the US, even, so I'm looking for
     # better ideas
 
-    zone = Time.now.zone
-
     # Are we in the US?
-
     if ["EST", "EDT",
         "CST", "CDT",
         "MST", "MDT",
-        "PST", "PDT"].include? zone
+        "PST", "PDT"].include? @zone
 
       dtest = [ 
         [false, 2000, 1, 1],
         [true,  2000, 7, 1],
+        [true,  2000, 4, 2, 4],
+        [false, 2000, 10, 29, 4],
+        [false, 2000, 4,2,1,59],   # Spring forward
+        [true,  2000, 4,2,3,0],
+        [true,  2000, 10,29,0,59], # Fall back
+        [false, 2000, 10,29,2,0]
       ]
 
-      dtest.push(
-                 [true,  2000, 4, 2, 4],
-                 [false, 2000, 10, 29, 4],
-                 [false, 2000, 4,2,1,59],   # Spring forward
-                 [true,  2000, 4,2,3,0],
-                 [true,  2000, 10,29,0,59], # Fall back
-                 [false, 2000, 10,29,2,0]
-                 )
-
       dtest.each do |x|
         result = x.shift
         assert_equal(result, Time.local(*x).isdst,
-                     "\nExpected #{x.join(',')} to be dst=#{result}")
+                     "\nExpected Time.local(#{x.join(',')}).isdst == #{result}")
       end
     else
       skipping("Don't know how to do timezones");
     end
   end
 
-  def test_iso8601
-    raise NotImplementedError, 'Need to write test_iso8601'
-  end
-
   def test_localtime
+    # TODO: this only tests gm -> local
     t = Time.now.gmtime
     utc = Time.at(t)
     assert(t.gmt?)
     t.localtime
     assert(!t.gmt?)
-    assert(t.asctime != utc.asctime)
+    assert_not_equal(t.asctime, utc.asctime)
   end
 
   def test_mday
@@ -440,14 +436,6 @@
     end
   end
 
-  def test_rfc2822
-    raise NotImplementedError, 'Need to write test_rfc2822'
-  end
-
-  def test_rfc822
-    raise NotImplementedError, 'Need to write test_rfc822'
-  end
-
   def test_sec
     checkComponent(:sec, 5)
   end
@@ -506,7 +494,10 @@
   end
 
   def test_succ
-    raise NotImplementedError, 'Need to write test_succ'
+    t1 = @loc
+    t2 = t1 + 1
+    t3 = t1.succ
+    assert_equal(t2, t3)
   end
 
   def test_to_a
@@ -526,7 +517,7 @@
 
   def test_to_f
     t = Time.at(10000,1066)
-    assert_equal(10000.001066, t.to_f)
+    assert_in_delta(10000.001066, t.to_f, 1e-7)
   end
 
   def test_to_i
@@ -537,9 +528,8 @@
   end
 
   def test_to_s
-    flunk "You can't use strftime to test to_s!"
-    t = Time.now
-    assert_equal(t.strftime("%a %b %d %H:%M:%S %Z %Y"),t.to_s)
+    assert_equal("Sat Feb 03 04:05:06 UTC 2001", @utc.to_s)
+    assert_equal("Sat Feb 03 04:05:06 #{@zone} 2001", @loc.to_s)
   end
 
   def test_tv_sec
@@ -549,48 +539,71 @@
     assert_equal(10000,t.tv_sec)
   end
 
+  def util_usec(s, u, method)
+    t = Time.at(s,u)
+    assert_equal(u,t.send(method))
+  end
+
   def test_tv_usec
-    t = Time.at(10000,1066)
-    assert_equal(1066,t.tv_usec)
+    util_usec(10000, 1066, :tv_usec)
+    util_usec(10000, 0, :tv_usec)
   end
 
   def test_usec
-    t = Time.at(10000,1066)
-    assert_equal(1066,t.usec)
+    util_usec(10000, 1066, :usec)
+    util_usec(10000, 0, :usec)
   end
 
   def test_utc
-    raise NotImplementedError, 'Need to write test_utc'
+    test_gmtime # REFACTOR to test both methods
   end
 
   def test_utc_eh
-    raise NotImplementedError, 'Need to write test_utc_eh'
+    test_gmt_eh # REFACTOR to test both methods
   end
 
   def test_utc_offset
-    raise NotImplementedError, 'Need to write test_utc_offset'
+    # TODO: figure out the year, month, & day edgecase setups
+    off = @utc - @loc
+    assert_equal(0, @utc.utc_offset)
+    assert_equal(off, @loc.utc_offset)
   end
 
   def test_wday
     t = Time.local(2001, 4, 1)
 
-    6.times {|i|
+    7.times { |i|
       assert_equal(i,t.wday)
       t += ONEDAYSEC
     }
   end
 
-  def test_xmlschema
-    raise NotImplementedError, 'Need to write test_xmlschema'
-  end
-
   def test_yday
-    t = Time.local(2001, 1, 1)
-    365.times {|i|
-      assert_equal(i+1,t.yday)
-      t += ONEDAYSEC
-    }
-    
+    # non-leap 1/1, 2/28,       3/1, 12/31
+    #     leap 1/1, 2/28, 2/29, 3/1, 12/31
+    # leap century (2000)
+    # want to do a non-leap century, but they are out of range.
+    # any others?
+
+    # non-leap year:
+    assert_equal(  1, Time.local(1999,  1,  1).yday)
+    assert_equal( 59, Time.local(1999,  2, 28).yday)
+    assert_equal( 60, Time.local(1999,  3,  1).yday)
+    assert_equal(365, Time.local(1999, 12, 31).yday)
+
+    # leap century:
+    assert_equal(  1, Time.local(2000,  1,  1).yday)
+    assert_equal( 59, Time.local(2000,  2, 28).yday)
+    assert_equal( 60, Time.local(2000,  2, 29).yday)
+    assert_equal( 61, Time.local(2000,  3,  1).yday)
+    assert_equal(366, Time.local(2000, 12, 31).yday)
+
+    # leap year:
+    assert_equal(  1, Time.local(2004,  1,  1).yday)
+    assert_equal( 59, Time.local(2004,  2, 28).yday)
+    assert_equal( 60, Time.local(2004,  2, 29).yday)
+    assert_equal( 61, Time.local(2004,  3,  1).yday)
+    assert_equal(366, Time.local(2004, 12, 31).yday)
   end
 
   def test_year
@@ -603,7 +616,7 @@
     t = Time.now.gmtime
     assert_equal(gmt, t.zone)
     t = Time.now
-    assert(gmt != t.zone)
+    assert_not_equal(gmt, t.zone)
   end
 
 end
--- /dev/null	Sun Apr 24 13:34:06 2005
+++ builtin/TestPack.rb	Sun Apr 24 13:12:42 2005
@@ -0,0 +1,222 @@
+$: << File.dirname($0) << File.join(File.dirname($0), "..")
+require 'rubicon'
+
+class TestPack < Rubicon::TestCase
+
+  def test_pack_A
+    a = %w(cat wombat x yy)
+    assert_equal "catwomx  yy ",          a.pack("A3A3A3A3")
+    assert_equal "cat",                   a.pack("A*")
+    assert_equal "cwx  yy ",              a.pack("A3@1A3@2A3A3")
+  end
+
+  def test_pack_a
+    a = %w(cat wombat x yy)
+    assert_equal "catwomx\000\000yy\000", a.pack("a3a3a3a3")
+    assert_equal "cat",                   a.pack("a*")
+    assert_equal "ca",                    a.pack("a2")
+    assert_equal "cat\000\000",           a.pack("a5")
+  end
+
+  def test_pack_B
+    assert_equal "\x61",     ["01100001"].pack("B8")
+    assert_equal "\x61",     ["01100001"].pack("B*")
+    assert_equal "\x61",     ["0110000100110111"].pack("B8")
+    assert_equal "\x61\x37", ["0110000100110111"].pack("B16")
+    assert_equal "\x61\x37", ["01100001", "00110111"].pack("B8B8")
+    assert_equal "\x60",     ["01100001"].pack("B4")
+    assert_equal "\x40",     ["01100001"].pack("B2")
+  end
+
+  def test_pack_b
+    assert_equal "\x86",     ["01100001"].pack("b8")
+    assert_equal "\x86",     ["01100001"].pack("b*")
+    assert_equal "\x86",     ["0110000100110111"].pack("b8")
+    assert_equal "\x86\xec", ["0110000100110111"].pack("b16")
+    assert_equal "\x86\xec", ["01100001", "00110111"].pack("b8b8")
+    assert_equal "\x06",     ["01100001"].pack("b4")
+    assert_equal "\x02",     ["01100001"].pack("b2")
+  end
+
+  def test_pack_C
+    assert_equal "ABC",      [ 65, 66, 67 ].pack("C3")
+    assert_equal "\377BC",   [ -1, 66, 67 ].pack("C*")
+  end
+
+  def test_pack_c
+    assert_equal "ABC",      [ 65, 66, 67 ].pack("c3")
+    assert_equal "\377BC",   [ -1, 66, 67 ].pack("c*")
+  end
+
+  def test_pack_H
+    assert_equal "AB\n\x10",  ["4142", "0a", "12"].pack("H4H2H1")
+    assert_equal "AB\n\x02",  ["1424", "a0", "21"].pack("h4h2h1")
+  end
+
+  def test_pack_M
+    assert_equal("abc=02def=\ncat=\n=01=\n", 
+                 ["abc\002def", "cat", "\001"].pack("M9M3M4"))
+  end
+
+  def test_pack_m
+    assert_equal "aGVsbG8K\n",  ["hello\n"].pack("m")
+  end
+
+  def test_pack_u
+    assert_equal ",:&5L;&\\*:&5L;&\\*\n",  ["hello\nhello\n"].pack("u")
+  end
+
+  def test_pack_U
+    assert_equal "\xc2\xa9B\xe2\x89\xa0", [0xa9, 0x42, 0x2260].pack("U*")
+  end
+
+  def test_pack_ugly
+    format = "c2x5CCxsdils_l_a6";
+    # Need the expression in here to force ary[5] to be numeric.  This avoids
+    # test2 failing because ary2 goes str->numeric->str and ary does not.
+    ary = [1, -100, 127, 128, 32767, 987.654321098/100.0,
+           12345, 123456, -32767, -123456, "abcdef"]
+    x    = ary.pack(format)
+    ary2 = x.unpack(format)
+
+    assert_equal ary.length, ary2.length
+    assert_equal ary.join(':'), ary2.join(':')
+    assert_not_nil(x =~ /def/)
+  end
+
+  def test_pack_untested
+    skipping "Not tested:
+        D,d & double-precision float, native format\\
+        E & double-precision float, little-endian byte order\\
+        e & single-precision float, little-endian byte order\\
+        F,f & single-precision float, native format\\
+        G & double-precision float, network (big-endian) byte order\\
+        g & single-precision float, network (big-endian) byte order\\
+        I & unsigned integer\\
+        i & integer\\
+        L & unsigned long\\
+        l & long\\
+
+        N & long, network (big-endian) byte order\\
+        n & short, network (big-endian) byte-order\\
+        P & pointer to a structure (fixed-length string)\\
+        p & pointer to a null-terminated string\\
+        S & unsigned short\\
+        s & short\\
+        V & long, little-endian byte order\\
+        v & short, little-endian byte order\\
+        X & back up a byte\\
+        x & null byte\\
+        Z & ASCII string (null padded, count is width)\\
+"
+  end
+
+end
+
+class TestUnpack < Rubicon::TestCase
+
+  def test_unpack_A
+    assert_equal ["cat", "wom", "x", "yy"], "catwomx  yy ".unpack("A3A3A3A3")
+
+    assert_equal ["cat"], "cat  \000\000".unpack("A*")
+    assert_equal ["cwx", "wx", "x", "yy"], "cwx  yy ".unpack("A3@1A3@2A3A3")
+  end
+
+  def test_unpack_a
+    assert_equal ["cat", "wom", "x\000\000", "yy\000"],
+                 "catwomx\000\000yy\000".unpack("a3a3a3a3")
+    assert_equal ["cat \000\000"], "cat \000\000".unpack("a*")
+    assert_equal ["ca"], "catdog".unpack("a2")
+    assert_equal ["cat\000\000"], "cat\000\000\000\000\000dog".unpack("a5")
+  end
+
+  def test_unpack_B
+    assert_equal ["01100001"], "\x61".unpack("B8")
+    assert_equal ["01100001"], "\x61".unpack("B*")
+    assert_equal ["0110000100110111"], "\x61\x37".unpack("B16")
+    assert_equal ["01100001", "00110111"], "\x61\x37".unpack("B8B8")
+    assert_equal ["0110"], "\x60".unpack("B4")
+
+    assert_equal ["01"], "\x40".unpack("B2")
+  end
+
+  def test_unpack_b
+    assert_equal ["01100001"], "\x86".unpack("b8")
+    assert_equal ["01100001"], "\x86".unpack("b*")
+
+    assert_equal ["0110000100110111"], "\x86\xec".unpack("b16")
+    assert_equal ["01100001", "00110111"], "\x86\xec".unpack("b8b8")
+
+    assert_equal ["0110"], "\x06".unpack("b4")
+    assert_equal ["01"], "\x02".unpack("b2")
+  end
+
+  def test_unpack_C
+    assert_equal [ 65, 66, 67 ],  "ABC".unpack("C3")
+    assert_equal [ 255, 66, 67 ], "\377BC".unpack("C*")
+  end
+
+  def test_unpack_c
+    assert_equal [ 65, 66, 67 ],  "ABC".unpack("c3")
+    assert_equal [ -1, 66, 67 ],  "\377BC".unpack("c*")
+  end
+    
+  def test_unpack_H
+    assert_equal ["4142", "0a", "1"], "AB\n\x10".unpack("H4H2H1")
+  end
+
+  def test_unpack_h
+    assert_equal ["1424", "a0", "2"], "AB\n\x02".unpack("h4h2h1")
+  end
+
+  def test_unpack_M
+    assert_equal ["abc\002defcat\001", "", ""],
+                 "abc=02def=\ncat=\n=01=\n".unpack("M9M3M4")
+  end
+
+  def test_unpack_m
+    assert_equal ["hello\n"], "aGVsbG8K\n".unpack("m")
+  end
+
+  def test_unpack_u
+    assert_equal ["hello\nhello\n"], ",:&5L;&\\*:&5L;&\\*\n".unpack("u")
+  end
+
+  def test_unpack_U
+    assert_equal [0xa9, 0x42, 0x2260], "\xc2\xa9B\xe2\x89\xa0".unpack("U*")
+  end
+
+  def test_unpack_skipped
+    skipping "Not tested:
+        D,d & double-precision float, native format\\
+        E & double-precision float, little-endian byte order\\
+        e & single-precision float, little-endian byte order\\
+        F,f & single-precision float, native format\\
+        G & double-precision float, network (big-endian) byte order\\
+        g & single-precision float, network (big-endian) byte order\\
+        I & unsigned integer\\
+        i & integer\\
+        L & unsigned long\\
+        l & long\\
+
+        m & string encoded in base64 (uuencoded)\\
+        N & long, network (big-endian) byte order\\
+        n & short, network (big-endian) byte-order\\
+        P & pointer to a structure (fixed-length string)\\
+        p & pointer to a null-terminated string\\
+        S & unsigned short\\
+        s & short\\
+        V & long, little-endian byte order\\
+        v & short, little-endian byte order\\
+        X & back up a byte\\
+        x & null byte\\
+        Z & ASCII string (null padded, count is width)\\
+"
+  end
+
+end
+
+if __FILE__ == $0 then
+  Rubicon::handleTests TestPack
+  Rubicon::handleTests TestUnpack
+end
