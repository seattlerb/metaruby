Index: rubicon.rb
===================================================================
RCS file: /var/cvs/rubytests/rubicon/rubicon.rb,v
retrieving revision 1.6
diff -d -u -r1.6 rubicon.rb
--- rubicon.rb	28 Dec 2004 15:07:38 -0000	1.6
+++ rubicon.rb	13 Jun 2005 07:07:05 -0000
@@ -175,33 +175,33 @@
   # Specify a range of versions, and run a test block if the current version
   # falls within that range.  
   def Version.in(range)
-    if(range.include?(VERSION)) then
-      yield
-    end
+    test = range.include?(VERSION)
+    yield if block_given? and test
+    return test
   end
 
   def Version.greater_than(version)
-    if(VERSION > version) then
-      yield
-    end
+    test = VERSION > version
+    yield if block_given? and test
+    return test
   end
 
   def Version.greater_or_equal(version)
-    if(VERSION >= version) then
-      yield
-    end
+    test = VERSION >= version
+    yield if block_given? and test
+    return test
   end
 
   def Version.less_than(version)
-    if(VERSION < version) then
-      yield
-    end
+    test = VERSION < version
+    yield if block_given? and test
+    return test
   end
 
   def Version.less_or_equal(version)
-    if(VERSION <= version) then
-      yield
-    end
+    test = VERSION <= version
+    yield if block_given? and test
+    return test
   end
  
 end
Index: builtin/TestHash.rb
===================================================================
RCS file: /var/cvs/rubytests/rubicon/builtin/TestHash.rb,v
retrieving revision 1.2
diff -d -u -r1.2 TestHash.rb
--- builtin/TestHash.rb	8 Jun 2005 02:26:55 -0000	1.2
+++ builtin/TestHash.rb	13 Jun 2005 07:07:05 -0000
@@ -5,121 +5,78 @@
 
 class TestHash < Test::Unit::TestCase
 
+  def inspect
+    self.name
+  end
+
   def setup
-    @cls = Hash
-    @h = @cls[
-      1 => 'one', 2 => 'two', 3 => 'three',
-      self => 'self', true => 'true', nil => 'nil',
-      'nil' => nil
+    @h = Hash[
+      1, 'one',
+      2, 'two',
+      3, 'three',
+      self, 'self',
+      true, 'true',
+      nil, 'nil',
+      'nil', nil
     ]
   end
 
-  def test_s_aref
-    h = @cls["a" => 100, "b" => 200]
+  def generic_index_tester(symbol)
+    res = @h.send symbol, *%w( dog cat horse ) 
+    assert_equal([nil, nil, nil], res)
+
+    res = @h.send symbol
+    assert_equal([], res)
+
+    res = @h.send symbol, 3, 2, 1, nil 
+    assert_equal(%w( three two one nil ), res)
+
+    res = @h.send symbol, 3, 99, 1, nil 
+    assert_equal([ 'three', nil, 'one', 'nil' ], res)
+  end
+
+  def generic_update_tester(symbol)
+    h1 = Hash[ 1, 2, 2, 3,     3, 4 ]
+    h2 = Hash[       2, 'two',       4, 'four' ]
+
+    ha = Hash[ 1, 2, 2, 'two', 3, 4, 4, 'four' ]
+    hb = Hash[ 1, 2, 2, 3,     3, 4, 4, 'four' ]
+
+    assert_equal(ha, h1.send(symbol, h2))
+    assert_equal(ha, h1)
+
+    h1 = Hash[ 1, 2, 2, 3, 3, 4 ]
+    h2 = Hash[ 2, 'two', 4, 'four' ]
+
+    assert_equal(hb, h2.send(symbol, h1))
+    assert_equal(hb, h2)
+  end
+
+  def test_class_index # Hash[blahblah]
+    h = Hash["a", 100, "b", 200]
     assert_equal(100, h['a'])
     assert_equal(200, h['b'])
     assert_nil(h['c'])
 
-    h = @cls.[]("a" => 100, "b" => 200)
+    h = Hash.[]("a", 100, "b", 200)
     assert_equal(100, h['a'])
     assert_equal(200, h['b'])
     assert_nil(h['c'])
   end
 
-  def test_s_new
-    h = @cls.new
-    assert_instance_of(@cls, h)
+  def test_initialize
+    h = Hash.new
+    assert_instance_of(Hash, h)
     assert_nil(h.default)
     assert_nil(h['spurious'])
 
-    h = @cls.new('default')
-    assert_instance_of(@cls, h)
+    h = Hash.new('default')
+    assert_instance_of(Hash, h)
     assert_equal('default', h.default)
     assert_equal('default', h['spurious'])
     
   end
 
-  def test_AREF # '[]'
-    t = Time.now
-    h = @cls[
-      1 => 'one', 2 => 'two', 3 => 'three',
-      self => 'self', t => 'time', nil => 'nil',
-      'nil' => nil
-    ]
-
-    assert_equal('one',   h[1])
-    assert_equal('two',   h[2])
-    assert_equal('three', h[3])
-    assert_equal('self',  h[self])
-    assert_equal('time',  h[t])
-    assert_equal('nil',   h[nil])
-    assert_equal(nil,     h['nil'])
-    assert_equal(nil,     h['koala'])
-
-    h1 = h.dup
-    h1.default = :default
-
-    assert_equal('one',    h1[1])
-    assert_equal('two',    h1[2])
-    assert_equal('three',  h1[3])
-    assert_equal('self',   h1[self])
-    assert_equal('time',   h1[t])
-    assert_equal('nil',    h1[nil])
-    assert_equal(nil,      h1['nil'])
-    assert_equal(:default, h1['koala'])
-
-
-  end
-
-  def test_ASET # '[]='
-    t = Time.now
-    h = @cls.new
-    h[1]     = 'one'
-    h[2]     = 'two'
-    h[3]     = 'three'
-    h[self]  = 'self'
-    h[t]     = 'time'
-    h[nil]   = 'nil'
-    h['nil'] = nil
-    assert_equal('one',   h[1])
-    assert_equal('two',   h[2])
-    assert_equal('three', h[3])
-    assert_equal('self',  h[self])
-    assert_equal('time',  h[t])
-    assert_equal('nil',   h[nil])
-    assert_equal(nil,     h['nil'])
-    assert_equal(nil,     h['koala'])
-
-    h[1] = 1
-    h[nil] = 99
-    h['nil'] = nil
-    z = [1,2]
-    h[z] = 256
-    assert_equal(1,       h[1])
-    assert_equal('two',   h[2])
-    assert_equal('three', h[3])
-    assert_equal('self',  h[self])
-    assert_equal('time',  h[t])
-    assert_equal(99,      h[nil])
-    assert_equal(nil,     h['nil'])
-    assert_equal(nil,     h['koala'])
-    assert_equal(256,     h[z])
-  end
-
-  def test_EQUAL # '=='
-    h1 = @cls[ "a" => 1, "c" => 2 ]
-    h2 = @cls[ "a" => 1, "c" => 2, 7 => 35 ]
-    h3 = @cls[ "a" => 1, "c" => 2, 7 => 35 ]
-    h4 = @cls[ ]
-    assert(h1 == h1)
-    assert(h2 == h2)
-    assert(h3 == h3)
-    assert(h4 == h4)
-    assert(!(h1 == h2))
-    assert(h2 == h3)
-    assert(!(h3 == h4))
-  end
-
   def test_clear
     assert(@h.size > 0)
     @h.clear
@@ -127,63 +84,74 @@
     assert_nil(@h[1])
   end
 
-  def test_clone
+  def util_clone(meth)
     for taint in [ false, true ]
       for frozen in [ false, true ]
-        a = @h.clone
+        desc = "#{taint}:#{frozen}"
+        a = @h.send(meth)
         a.taint  if taint
         a.freeze if frozen
-        b = a.clone
+        b = a.send(meth)
 
-        assert_equal(a, b)
-        assert(a.__id__ != b.__id__)
-        assert_equal(a.frozen?, b.frozen?)
-        assert_equal(a.tainted?, b.tainted?)
+        assert_equal(a, b, "equal: " + desc)
+        assert_not_equal(a.__id__, b.__id__, "id: " + desc)
+        exp_frozen = case meth
+                     when :dup then
+                       false
+                     when :clone then
+                       a.frozen?
+                     else
+                       raise "Unknown method #{meth}"
+                     end
+        assert_equal(exp_frozen, b.frozen?,  "frozen: " + desc)
+        assert_equal(a.tainted?, b.tainted?, "tainted: " + desc)
       end
     end
   end
 
+  def test_clone
+    util_clone(:clone)
+  end
+
   def test_default
     assert_nil(@h.default)
-    h = @cls.new(:xyzzy)
+    h = Hash.new(:xyzzy)
     assert_equal(:xyzzy, h.default)
   end
 
-  def test_default=
+  def test_default_equals
     assert_nil(@h.default)
     @h.default = :xyzzy
     assert_equal(:xyzzy, @h.default)
   end
 
-  Version.greater_or_equal("1.6.8") do 
-    def test_default_proc
-      last = nil
-      h = Hash.new { |k, v| last=[k.inspect, v] }
-      assert_not_nil(h.default_proc)
-      assert_equal(["{}",42], h[42])
-      h[3] = -3
-      assert_equal(["{3=>-3}",42], h[42])
-      h[42] = 666
-      assert_equal(666, h[42])
-      assert_equal(["{3=>-3, 42=>666}",43], h[43])
-      last = nil
-      h[42] = nil
-      assert_nil(last)
-      assert_equal(nil, h[42])
-      last = nil
-      h.delete(42)
-      h.delete(3)
-      assert_nil(last)
-      last = nil
-      assert_equal(["{}",42], h[42])
-      assert_equal(["{}",42], last)
-    end
+  def test_default_proc
+    last = nil
+    h = Hash.new { |hash, k| last=[hash.inspect, k] }
+    assert_not_nil(h.default_proc)
+    assert_equal(["{}",42], h[42])
+    h[3] = -3
+    assert_equal(["{3=>-3}",42], h[42])
+    h[42] = 666
+    assert_equal(666, h[42])
+    assert_equal(["{3=>-3, 42=>666}",43], h[43])
+    last = nil
+    h[42] = nil
+    assert_nil(last)
+    assert_equal(nil, h[42])
+    last = nil
+    h.delete(42)
+    h.delete(3)
+    assert_nil(last)
+    last = nil
+    assert_equal(["{}",42], h[42])
+    assert_equal(["{}",42], last)
   end
 
   def test_delete
-    h1 = @cls[ 1 => 'one', 2 => 'two', true => 'true' ]
-    h2 = @cls[ 1 => 'one', 2 => 'two' ]
-    h3 = @cls[ 2 => 'two' ]
+    h1 = Hash[ 1, 'one', 2, 'two', true, 'true' ]
+    h2 = Hash[ 1, 'one', 2, 'two' ]
+    h3 = Hash[ 2, 'two' ]
 
     assert_equal('true', h1.delete(true))
     assert_equal(h2, h1)
@@ -192,23 +160,24 @@
     assert_equal(h3, h1)
 
     assert_equal('two', h1.delete(2))
-    assert_equal(@cls[], h1)
+    assert_equal(Hash[], h1)
 
     assert_nil(h1.delete(99))
-    assert_equal(@cls[], h1)
+    assert_equal(Hash[], h1)
 
     assert_equal('default 99', h1.delete(99) {|i| "default #{i}" })
   end
 
   def test_delete_if
-    base = @cls[ 1 => 'one', 2 => false, true => 'true', 'cat' => 99 ]
-    h1   = @cls[ 1 => 'one', 2 => false, true => 'true' ]
-    h2   = @cls[ 2 => false, 'cat' => 99 ]
-    h3   = @cls[ 2 => false ]
+    base = Hash[ 1, 'one', 2, false, true, 'true', 'cat', 99 ]
+    h1   = Hash[ 1, 'one', 2, false, true, 'true' ]
+    h2   = Hash[ 2, false, 'cat', 99 ]
+    h3   = Hash[ 2, false ]
 
     h = base.dup
     assert_equal(h, h.delete_if { false })
-    assert_equal(@cls[], h.delete_if { true })
+    h.delete_if { true }
+    assert_equal(Hash[], h)
 
     h = base.dup
     assert_equal(h1, h.delete_if {|k,v| k.instance_of?(String) })
@@ -224,60 +193,66 @@
   end
 
   def test_dup
-    for taint in [ false, true ]
-      for frozen in [ false, true ]
-        a = @h.dup
-        a.taint  if taint
-        a.freeze if frozen
-        b = a.dup
-
-        assert_equal(a, b)
-        assert(a.__id__ != b.__id__)
-        assert_equal(false, b.frozen?)
-        assert_equal(a.tainted?, b.tainted?)
-      end
-    end
+    util_clone(:dup)
   end
 
   def test_each
     count = 0
-    @cls[].each { |k, v| count + 1 }
+    Hash[].each { |k, v| count + 1 }
     assert_equal(0, count)
 
+    # constructive test, should always work.
+    h = @h
+    r = Hash[]
+    h.each do |k, v|
+      r[k] = v
+    end
+    assert_equal(r, h)
+
+    # destructive test, probably stupid.
     h = @h
     h.each do |k, v|
       assert_equal(v, h.delete(k))
     end
-    assert_equal(@cls[], h)
+    assert_equal(Hash[], h)
   end
 
   def test_each_key
     count = 0
-    @cls[].each_key { |k| count + 1 }
+    Hash[].each_key { |k| count + 1 }
     assert_equal(0, count)
 
     h = @h
     h.each_key do |k|
       h.delete(k)
     end
-    assert_equal(@cls[], h)
+    assert_equal(Hash[], h)
   end
 
   def test_each_pair
     count = 0
-    @cls[].each_pair { |k, v| count + 1 }
+    Hash[].each_pair { |k, v| count + 1 }
     assert_equal(0, count)
 
+    # constructive test, should always work.
+    h = @h
+    r = Hash[]
+    h.each do |k, v|
+      r[k] = v
+    end
+    assert_equal(h, r)
+
+    # destructive test, probably stupid.
     h = @h
     h.each_pair do |k, v|
       assert_equal(v, h.delete(k))
     end
-    assert_equal(@cls[], h)
+    assert_equal(Hash[], h)
   end
 
   def test_each_value
     res = []
-    @cls[].each_value { |v| res << v }
+    Hash[].each_value { |v| res << v }
     assert_equal(0, [].length)
 
     @h.each_value { |v| res << v }
@@ -290,13 +265,27 @@
     assert_equal([], res - expected)
   end
 
-  def test_empty?
-    assert(@cls[].empty?)
+  def test_empty_eh
+    assert(Hash[].empty?)
     assert(!@h.empty?)
   end
 
+  def test_equals2 # '=='
+    h1 = Hash[ "a", 1, "c", 2 ]
+    h2 = Hash[ "a", 1, "c", 2, 7, 35 ]
+    h3 = Hash[ "a", 1, "c", 2, 7, 35 ]
+    h4 = Hash[ ]
+    assert(h1 == h1)
+    assert(h2 == h2)
+    assert(h3 == h3)
+    assert(h4 == h4)
+    assert(!(h1 == h2))
+    assert(h2 == h3)
+    assert(!(h3 == h4))
+  end
+
   def test_fetch
-    assert_raise(IndexError) { @cls[].fetch(1) }
+    assert_raise(IndexError) { Hash[].fetch(1) }
     assert_raise(IndexError) { @h.fetch('gumby') }
     assert_equal('gumbygumby',     @h.fetch('gumby') {|k| k*2} )
     assert_equal('pokey',          @h.fetch('gumby', 'pokey'))
@@ -307,77 +296,121 @@
   end
 
 
-  def test_has_key?
-    assert(!@cls[].has_key?(1))
-    assert(!@cls[].has_key?(nil))
+  def test_has_key_eh
+    assert(!Hash[].has_key?(1))
+    assert(!Hash[].has_key?(nil))
     assert(@h.has_key?(nil))
     assert(@h.has_key?(1))
     assert(!@h.has_key?('gumby'))
   end
 
-  def test_has_value?
-    assert(!@cls[].has_value?(1))
-    assert(!@cls[].has_value?(nil))
+  def test_has_value_eh
+    assert(!Hash[].has_value?(1))
+    assert(!Hash[].has_value?(nil))
     assert(@h.has_value?('one'))
     assert(@h.has_value?(nil))
     assert(!@h.has_value?('gumby'))
   end
 
-  def test_include?
-    assert(!@cls[].include?(1))
-    assert(!@cls[].include?(nil))
+  def test_include_eh
+    assert(!Hash[].include?(1))
+    assert(!Hash[].include?(nil))
     assert(@h.include?(nil))
     assert(@h.include?(1))
     assert(!@h.include?('gumby'))
   end
 
-  def test_index
+  def test_index # '[]'
+    t = Time.now
+    h = Hash[1, 'one', 2, 'two', 3, 'three',
+      self, 'self',
+      t, 'time',
+      nil, 'nil',
+      'nil', nil
+    ]
+
+    assert_equal('one',   h[1])
+    assert_equal('two',   h[2])
+    assert_equal('three', h[3])
+    assert_equal('self',  h[self])
+    assert_equal('time',  h[t])
+    assert_equal('nil',   h[nil])
+    assert_equal(nil,     h['nil'])
+    assert_equal(nil,     h['koala'])
+
+    h1 = h.dup
+    h1.default = :default
+
+    assert_equal('one',    h1[1])
+    assert_equal('two',    h1[2])
+    assert_equal('three',  h1[3])
+    assert_equal('self',   h1[self])
+    assert_equal('time',   h1[t])
+    assert_equal('nil',    h1[nil])
+    assert_equal(nil,      h1['nil'])
+    assert_equal(:default, h1['koala'])
+  end
+
+  def test_index_equals # '[]='
+    t = Time.now
+    h = Hash.new
+    h[1]     = 'one'
+    h[2]     = 'two'
+    h[3]     = 'three'
+    h[self]  = 'self'
+    h[t]     = 'time'
+    h[nil]   = 'nil'
+    h['nil'] = nil
+    assert_equal('one',   h[1])
+    assert_equal('two',   h[2])
+    assert_equal('three', h[3])
+    assert_equal('self',  h[self])
+    assert_equal('time',  h[t])
+    assert_equal('nil',   h[nil])
+    assert_equal(nil,     h['nil'])
+    assert_equal(nil,     h['koala'])
+
+    h[1] = 1
+    h[nil] = 99
+    h['nil'] = nil
+    z = [1,2]
+    h[z] = 256
+    assert_equal(1,       h[1])
+    assert_equal('two',   h[2])
+    assert_equal('three', h[3])
+    assert_equal('self',  h[self])
+    assert_equal('time',  h[t])
+    assert_equal(99,      h[nil])
+    assert_equal(nil,     h['nil'])
+    assert_equal(nil,     h['koala'])
+    assert_equal(256,     h[z])
+  end
+
+  def test_index_literal
     assert_equal(1,     @h.index('one'))
     assert_equal(nil,   @h.index('nil'))
     assert_equal('nil', @h.index(nil))
 
     assert_equal(nil,   @h.index('gumby'))
-    assert_equal(nil,   @cls[].index('gumby'))
+    assert_equal(nil,   Hash[].index('gumby'))
   end
 
-  # this clutters up the alphabetic ordering of methods
-  Version.less_than("1.7.2") do
-    def test_indexes
-      generic_index_tester(:indexes)
-    end
-  
-    def test_indices
-      generic_index_tester(:indices)
-    end
-  end
-  Version.in("1.7.2"..."1.8.1") do
-    def test_select
-      generic_index_tester(:select)
-    end
+  def test_indexes
+    generic_index_tester(:indexes)
   end
-  Version.greater_or_equal("1.8.1") do 
-    def test_values_at
-      generic_index_tester(:values_at)
-    end
+  
+  def test_indices
+    generic_index_tester(:indices)
   end
-  def generic_index_tester(symbol)
-    res = @h.send symbol, *%w( dog cat horse ) 
-    assert(res.length == 3)
-    assert_equal([nil, nil, nil], res)
 
-    res = @h.send symbol
-    assert(res.length == 0)
-
-    res = @h.send symbol, 3, 2, 1, nil 
-    assert(res.length == 4)
-    assert_equal(%w( three two one nil ), res)
-
-    res = @h.send symbol, 3, 99, 1, nil 
-    assert(res.length == 4)
-    assert_equal([ 'three', nil, 'one', 'nil' ], res)
+  def test_inspect
+    assert_equal("{}", Hash[].inspect)
+    @h.delete(self)
+    s = @h.inspect
+    s = "{" + s[1..-2].split(/, /).sort.join(', ') + "}"
+    assert_equal("{\"nil\"=>nil, 1=>\"one\", 2=>\"two\", 3=>\"three\", nil=>\"nil\", true=>\"true\"}", s)
   end
 
-
   def test_invert
     h = @h.invert
     assert_equal(1, h['one'])
@@ -388,22 +421,22 @@
       assert(@h.has_key?(v))    # not true in general, but works here
     end
 
-    h = @cls[ 'a' => 1, 'b' => 2, 'c' => 1].invert
+    h = Hash[ 'a', 1, 'b', 2, 'c', 1].invert
     assert_equal(2, h.length)
     assert(h[1] == 'a' || h[1] == 'c')
     assert_equal('b', h[2])
   end
 
-  def test_key?
-    assert(!@cls[].key?(1))
-    assert(!@cls[].key?(nil))
+  def test_key_eh
+    assert(!Hash[].key?(1))
+    assert(!Hash[].key?(nil))
     assert(@h.key?(nil))
     assert(@h.key?(1))
     assert(!@h.key?('gumby'))
   end
 
   def test_keys
-    assert_equal([], @cls[].keys)
+    assert_equal([], Hash[].keys)
 
     keys = @h.keys
     expected = []
@@ -413,58 +446,68 @@
   end
 
   def test_length
-    assert_equal(0, @cls[].length)
+    assert_equal(0, Hash[].length)
     assert_equal(7, @h.length)
   end
 
-  def test_member?
-    assert(!@cls[].member?(1))
-    assert(!@cls[].member?(nil))
+  def test_member_eh
+    assert(!Hash[].member?(1))
+    assert(!Hash[].member?(nil))
     assert(@h.member?(nil))
     assert(@h.member?(1))
     assert(!@h.member?('gumby'))
   end
 
-  Version.greater_or_equal("1.6.8") do 
-    def test_merge
-      h1 = @cls[ 1 => 2, 2 => 3, 3 => 4 ]
-      h2 = @cls[ 2 => 'two', 4 => 'four' ]
-      hmerge = @cls[ 1 => 2, 2 => 'two', 3 => 4, 4 => 'four' ]
-      h1clone = h1.clone
-      assert_equal(hmerge, h1.merge(h2))
-      assert_equal(h1clone, h1)
-      assert_not_equal(hmerge, h1)
+  def test_merge
+    h1 = Hash[ 1, 2, 2, 3, 3, 4 ]
+    h2 = Hash[ 2, 'two', 4, 'four' ]
+    hmerge = Hash[ 1, 2, 2, 'two', 3, 4, 4, 'four' ]
+    h1clone = h1.clone
+    assert_equal(hmerge, h1.merge(h2))
+    assert_equal(h1clone, h1)
+    assert_not_equal(hmerge, h1)
 
-      h1 = @cls[ 1 => 2, 2 => 3, 3 => 4 ]
-      h2 = @cls[ 2 => 'two', 4 => 'four' ]
-      hmerge = @cls[ 1 => 2, 2 => 3, 3 => 4, 4 => 'four' ]
-      h2clone = h2.clone
-      assert_equal(hmerge, h2.merge(h1))
-      assert_equal(h2clone, h2)
-      assert_not_equal(hmerge, h2)
-    end
+    h1 = Hash[ 1, 2, 2, 3, 3, 4 ]
+    h2 = Hash[ 2, 'two', 4, 'four' ]
+    hmerge = Hash[ 1, 2, 2, 3, 3, 4, 4, 'four' ]
+    h2clone = h2.clone
+    assert_equal(hmerge, h2.merge(h1))
+    assert_equal(h2clone, h2)
+    assert_not_equal(hmerge, h2)
+  end
+
+  def test_merge_bang
+    h1 = Hash[ "a", 100, "b", 200 ]
+    h2 = Hash[ "b", 254, "c", 300 ]
+    expected = Hash["a", 100, "b", 254, "c", 300]
+    h1clone = h1.clone
+    assert_equal(expected, h1.merge!(h2))
+    assert_not_equal(h1clone, h1)
   end
 
   def test_rehash
     a = [ "a", "b" ]
     c = [ "c", "d" ]
-    h = @cls[ a => 100, c => 300 ]
+    h = Hash[ a, 100, c, 300 ]
     assert_equal(100, h[a])
     a[0] = "z"
-    assert_nil(h[a])
+# HACK assert_nil(h[a]) # this is current behavior, but not sure if spec
     h.rehash
     assert_equal(100, h[a])
+
+    # TODO: If +Hash#rehash+ is called while an iterator is traversing the hash, an +IndexError+ will be raised in the iterator.
+
   end
 
   def test_reject
-    base = @cls[ 1 => 'one', 2 => false, true => 'true', 'cat' => 99 ]
-    h1   = @cls[ 1 => 'one', 2 => false, true => 'true' ]
-    h2   = @cls[ 2 => false, 'cat' => 99 ]
-    h3   = @cls[ 2 => false ]
+    base = Hash[ 1, 'one', 2, false, true, 'true', 'cat', 99 ]
+    h1   = Hash[ 1, 'one', 2, false, true, 'true' ]
+    h2   = Hash[ 2, false, 'cat', 99 ]
+    h3   = Hash[ 2, false ]
 
     h = base.dup
     assert_equal(h, h.reject { false })
-    assert_equal(@cls[], h.reject { true })
+    assert_equal(Hash[], h.reject { true })
 
     h = base.dup
     assert_equal(h1, h.reject {|k,v| k.instance_of?(String) })
@@ -475,15 +518,15 @@
     assert_equal(base, h)
   end
 
-  def test_reject!
-    base = @cls[ 1 => 'one', 2 => false, true => 'true', 'cat' => 99 ]
-    h1   = @cls[ 1 => 'one', 2 => false, true => 'true' ]
-    h2   = @cls[ 2 => false, 'cat' => 99 ]
-    h3   = @cls[ 2 => false ]
+  def test_reject_bang
+    base = Hash[ 1, 'one', 2, false, true, 'true', 'cat', 99 ]
+    h1   = Hash[ 1, 'one', 2, false, true, 'true' ]
+    h2   = Hash[ 2, false, 'cat', 99 ]
+    h3   = Hash[ 2, false ]
 
     h = base.dup
     assert_equal(nil, h.reject! { false })
-    assert_equal(@cls[],  h.reject! { true })
+    assert_equal(Hash[],  h.reject! { true })
 
     h = base.dup
     assert_equal(h1, h.reject! {|k,v| k.instance_of?(String) })
@@ -499,8 +542,8 @@
   end
 
   def test_replace
-    h = @cls[ 1 => 2, 3 => 4 ]
-    h1 = h.replace(@cls[ 9 => 8, 7 => 6 ])
+    h = Hash[ 1, 2, 3, 4 ]
+    h1 = h.replace(Hash[ 9, 8, 7, 6 ])
     assert_equal(h, h1)
     assert_equal(8, h[9])
     assert_equal(6, h[7])
@@ -508,6 +551,18 @@
     assert_nil(h[2])
   end
 
+  def test_select
+    generic_index_tester(:select)
+  end if Version.in("1.7.2"..."1.8.1") # FIX: this isn't right
+
+  def test_select
+    h = Hash["a", 100, "b", 200, "c", 300]
+    r = h.select {|k,v| k > "a"}
+    assert_equal([["b", 200], ["c", 300]], r.sort_by {|o| o.first })
+    r = h.select {|k,v| v < 200}
+    assert_equal([["a", 100]], r)
+  end if Version.greater_or_equal("1.8.2")
+
   def test_shift
     h = @h.dup
     
@@ -521,25 +576,26 @@
   end
 
   def test_size
-    assert_equal(0, @cls[].length)
+    assert_equal(0, Hash[].length)
     assert_equal(7, @h.length)
   end
 
   def test_sort
-    h = @cls[].sort
+    h = Hash.new
+    h = h.sort
     assert_equal([], h)
 
-    h = @cls[ 1 => 1, 2 => 1 ].sort
+    h = Hash[ 1, 1, 2, 1 ].sort
     assert_equal([[1,1], [2,1]], h)
 
-    h = @cls[ 'cat' => 'feline', 'ass' => 'asinine', 'bee' => 'beeline' ]
+    h = Hash[ 'cat', 'feline', 'ass', 'asinine', 'bee', 'beeline' ]
     h1 = h.sort
     assert_equal([ %w(ass asinine), %w(bee beeline), %w(cat feline)], h1)
   end
 
   def test_store
     t = Time.now
-    h = @cls.new
+    h = Hash.new
     h.store(1, 'one')
     h.store(2, 'two')
     h.store(3, 'three')
@@ -570,9 +626,9 @@
   end
 
   def test_to_a
-    assert_equal([], @cls[].to_a)
-    assert_equal([[1,2]], @cls[ 1=>2 ].to_a)
-    a = @cls[ 1=>2, 3=>4, 5=>6 ].to_a
+    assert_equal([], Hash[].to_a)
+    assert_equal([[1,2]], Hash[ 1, 2 ].to_a)
+    a = Hash[ 1, 2, 3, 4, 5, 6 ].to_a
     assert_equal([1,2], a.delete([1,2]))
     assert_equal([3,4], a.delete([3,4]))
     assert_equal([5,6], a.delete([5,6]))
@@ -585,48 +641,30 @@
   end
 
   def test_to_s
-    h = @cls[ 1 => 2, "cat" => "dog", 1.5 => :fred ]
+    h = Hash[ 1, 2, "cat", "dog", 1.5, :fred ]
     assert_equal(h.to_a.join, h.to_s)
     $, = ":"
     assert_equal(h.to_a.join, h.to_s)
-    h = @cls[]
+    h = Hash[]
     assert_equal(h.to_a.join, h.to_s)
     $, = nil
   end
 
   def test_update
     generic_update_tester(:update)
-    Version.greater_or_equal("1.6.8") do 
-      generic_update_tester(:merge!)
-    end
-  end
-  def generic_update_tester(symbol)
-    h1 = @cls[ 1 => 2, 2 => 3, 3 => 4 ]
-    h2 = @cls[ 2 => 'two', 4 => 'four' ]
-
-    ha = @cls[ 1 => 2, 2 => 'two', 3 => 4, 4 => 'four' ]
-    hb = @cls[ 1 => 2, 2 => 3, 3 => 4, 4 => 'four' ]
-
-    assert_equal(ha, h1.send(symbol, h2))
-    assert_equal(ha, h1)
-
-    h1 = @cls[ 1 => 2, 2 => 3, 3 => 4 ]
-    h2 = @cls[ 2 => 'two', 4 => 'four' ]
-
-    assert_equal(hb, h2.send(symbol, h1))
-    assert_equal(hb, h2)
+    generic_update_tester(:merge!)
   end
 
-  def test_value?
-    assert(!@cls[].value?(1))
-    assert(!@cls[].value?(nil))
+  def test_value_eh
+    assert(!Hash[].value?(1))
+    assert(!Hash[].value?(nil))
     assert(@h.value?(nil))
     assert(@h.value?('one'))
     assert(!@h.value?('gumby'))
   end
 
   def test_values
-    assert_equal([], @cls[].values)
+    assert_equal([], Hash[].values)
 
     vals = @h.values
     expected = []
@@ -635,4 +673,10 @@
     assert_equal([], expected - vals)
   end
 
+  def test_values_at
+    generic_index_tester(:values_at)
+  end if Version.greater_or_equal("1.8.1")
+
 end
+
+Rubicon::handleTests(TestHash) if $0 == __FILE__
